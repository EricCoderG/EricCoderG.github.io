<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>cpp-header</title>
    <link href="/2022/10/04/cpp-header/"/>
    <url>/2022/10/04/cpp-header/</url>
    
    <content type="html"><![CDATA[<p>由于在上机考试的时候编辑器的原因，在这里整理了一些常用函数以及需要的头文件</p><span id="more"></span><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">/**memset是一个初始化函数，作用是将某一块内存中的全部设置为指定的值。</span><br><span class="hljs-comment">s指向要填充的内存块。</span><br><span class="hljs-comment">c是要被设置的值。</span><br><span class="hljs-comment">n是要被设置该值的字符数。</span><br><span class="hljs-comment">返回类型是一个指向存储区s的指针。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *s, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> n)</span></span>; <br></code></pre></td></tr></table></figure><h3 id="algorithm-头文件"><a href="#algorithm-头文件" class="headerlink" title="algorithm 头文件"></a>algorithm 头文件</h3><p>这里面有许多非常好用的函数（（（</p><p>还有对于区间的限定似乎都是左开右闭？</p><h4 id="max-min-abs"><a href="#max-min-abs" class="headerlink" title="max(),min(),abs()"></a>max(),min(),abs()</h4><p><code>abs()</code>函数只能用于求整型变量的绝对值，而<code>#include&lt;cmath&gt;</code>中的<code>fabs()</code>函数还可用于求浮点型变量的绝对值，不要搞混~</p><h4 id="交换函数：swap"><a href="#交换函数：swap" class="headerlink" title="交换函数：swap()"></a>交换函数：swap()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//用来交换x和y的值</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>;<br><span class="hljs-built_in">swap</span>(a,b);<br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b;<br><span class="hljs-comment">//输出4 3</span><br></code></pre></td></tr></table></figure><h4 id="翻转函数：reverse"><a href="#翻转函数：reverse" class="headerlink" title="翻转函数：reverse()"></a>翻转函数：reverse()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>,<span class="hljs-number">55</span>&#125;;<br><span class="hljs-built_in">reverse</span>(a+<span class="hljs-number">3</span>,a+<span class="hljs-number">5</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)   cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-comment">//输出11 22 33 55 44</span><br></code></pre></td></tr></table></figure><h4 id="排序函数：sort"><a href="#排序函数：sort" class="headerlink" title="排序函数：sort()"></a>排序函数：sort()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">55</span>,<span class="hljs-number">44</span>,<span class="hljs-number">33</span>,<span class="hljs-number">22</span>,<span class="hljs-number">11</span>&#125;;<br><span class="hljs-built_in">sort</span>(a,a+<span class="hljs-number">5</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-comment">//输出:11 22 33 44 55</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b; <br>&#125;<br><span class="hljs-built_in">sort</span>(a,a+<span class="hljs-number">5</span>,cmp);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-comment">//输出:55 44 33 22 11</span><br></code></pre></td></tr></table></figure><h4 id="查找函数：find"><a href="#查找函数：find" class="headerlink" title="查找函数：find()"></a>查找函数：find()</h4><p>查找某数组指定区间x-y内是否有x，若有，则返回该位置的地址，若没有，则返回该数组第n+1个值的地址。(好烦有木有，为啥要返回地址。还要转化o(╥﹏╥)o)</p><h4 id="查找函数：upper-bound-、lower-bound"><a href="#查找函数：upper-bound-、lower-bound" class="headerlink" title="查找函数：upper_bound()、lower_bound()"></a>查找函数：upper_bound()、lower_bound()</h4><p><code>upper_bound()</code>：查找第一个大于x的值的位置<br><code>lower_bound()</code>：查找第一个大于等于x的值的位置<br>同样是返回地址，用法和<code>find()</code>函数一毛一样，限制条件也一毛一样，照着扒就行了。</p><h4 id="填充函数：fill"><a href="#填充函数：fill" class="headerlink" title="填充函数：fill()"></a>填充函数：fill()</h4><p>在区间内填充某一个值。同样<strong>适用所有类型数组，容器</strong>。</p><h4 id="查找某值出现的次数：count"><a href="#查找某值出现的次数：count" class="headerlink" title="查找某值出现的次数：count()"></a>查找某值出现的次数：count()</h4><h4 id="求最大公因数：-gcd"><a href="#求最大公因数：-gcd" class="headerlink" title="求最大公因数：__gcd()"></a>求最大公因数：__gcd()</h4><p><code>__gcd()</code> 需要写两个下划线！</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp-坑</title>
    <link href="/2022/10/04/cpp-%E5%9D%91/"/>
    <url>/2022/10/04/cpp-%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>这篇博客整理了自己在学习cpp时踩的一些坑……</p><span id="more"></span><h4 id="头文件中的模板类编译时的一个坑及其原因"><a href="#头文件中的模板类编译时的一个坑及其原因" class="headerlink" title="头文件中的模板类编译时的一个坑及其原因"></a>头文件中的模板类编译时的一个坑及其原因</h4><p>如果把模板类的声明和定义都放在头文件中。需要用到模板类的时候，只需要包含该头文件，然后进行实例化。</p><p>如果模板类的声明和定义分别放在头文件和源文件中。当实例化的时候，只包含头文件会发证链接错误。</p><p>原因是模板类的实例化要分成两个步骤，模板的特例化和特例的实例化。</p><p>编译器在编译阶段，由于没有定义，所以编译器不能生成具体的模板特例，但是这并不会报错误，编译器将把问题抛给链接器来做。在编译源文件的时候，程序找不到该模板的特例，只是有模板而已，所以无法生成对象。所以会发生错误。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp-tips</title>
    <link href="/2022/09/29/cpp-tips/"/>
    <url>/2022/09/29/cpp-tips/</url>
    
    <content type="html"><![CDATA[<p>这篇博客整理了自己学习cpp过程中遇到的一些小技巧和想法，会持续更新</p><span id="more"></span><h4 id="cpp删除容器中重复元素的方法："><a href="#cpp删除容器中重复元素的方法：" class="headerlink" title="cpp删除容器中重复元素的方法："></a>cpp删除容器中重复元素的方法：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">a.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>()),a.<span class="hljs-built_in">end</span>())；<br></code></pre></td></tr></table></figure><h4 id="stl中有关排列组合的api"><a href="#stl中有关排列组合的api" class="headerlink" title="stl中有关排列组合的api"></a>stl中有关排列组合的api</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">//func();</span><br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next_permutation</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()));<br></code></pre></td></tr></table></figure><h4 id="lower-bound-amp-amp-upper-bound"><a href="#lower-bound-amp-amp-upper-bound" class="headerlink" title="lower_bound &amp;&amp; upper_bound"></a>lower_bound &amp;&amp; upper_bound</h4><p>lower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找元素的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在从小到大的排序数组中,以vector&lt;int&gt; nums为例子</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><span class="hljs-type">int</span> idx = <span class="hljs-built_in">lower_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target) - nums.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> idx = <span class="hljs-built_in">upper_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target) - nums.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-comment">//在从大到小的排序数组中，重载lower_bound()和upper_bound()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">lower_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">upper_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure><h4 id="能读入空格和回车符的输入方式"><a href="#能读入空格和回车符的输入方式" class="headerlink" title="能读入空格和回车符的输入方式"></a>能读入空格和回车符的输入方式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s;<br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> (cin.<span class="hljs-built_in">peek</span>() != EOF) &#123;<br>    c = cin.<span class="hljs-built_in">get</span>();<br>    s += c;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
