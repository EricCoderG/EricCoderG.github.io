<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>cpp-header</title>
    <link href="/2022/10/04/cpp-header/"/>
    <url>/2022/10/04/cpp-header/</url>
    
    <content type="html"><![CDATA[<p>由于在上机考试的时候编辑器的原因，在这里整理了一些常用函数以及需要的头文件</p><h4 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">/**memset是一个初始化函数，作用是将某一块内存中的全部设置为指定的值。</span><br><span class="hljs-comment">s指向要填充的内存块。</span><br><span class="hljs-comment">c是要被设置的值。</span><br><span class="hljs-comment">n是要被设置该值的字符数。</span><br><span class="hljs-comment">返回类型是一个指向存储区s的指针。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *s, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> n)</span></span>; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp-坑</title>
    <link href="/2022/10/04/cpp-%E5%9D%91/"/>
    <url>/2022/10/04/cpp-%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>这篇博客整理了自己在学习cpp时踩的一些坑，会持续更新</p><h4 id="头文件中的模板类编译时的一个坑及其原因"><a href="#头文件中的模板类编译时的一个坑及其原因" class="headerlink" title="头文件中的模板类编译时的一个坑及其原因"></a>头文件中的模板类编译时的一个坑及其原因</h4><p>如果把模板类的声明和定义都放在头文件中。需要用到模板类的时候，只需要包含该头文件，然后进行实例化。</p><p>如果模板类的声明和定义分别放在头文件和源文件中。当实例化的时候，只包含头文件会发证链接错误。</p><p>原因是模板类的实例化要分成两个步骤，模板的特例化和特例的实例化。</p><p>编译器在编译阶段，由于没有定义，所以编译器不能生成具体的模板特例，但是这并不会报错误，编译器将把问题抛给链接器来做。在编译源文件的时候，程序找不到该模板的特例，只是有模板而已，所以无法生成对象。所以会发生错误。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp-tips</title>
    <link href="/2022/09/29/cpp-tips/"/>
    <url>/2022/09/29/cpp-tips/</url>
    
    <content type="html"><![CDATA[<p>这篇博客整理了自己学习cpp过程中遇到的一些小技巧和想法，会持续更新</p><span id="more"></span><h4 id="cpp删除容器中重复元素的方法："><a href="#cpp删除容器中重复元素的方法：" class="headerlink" title="cpp删除容器中重复元素的方法："></a>cpp删除容器中重复元素的方法：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">a.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>()),a.<span class="hljs-built_in">end</span>())；<br></code></pre></td></tr></table></figure><h4 id="stl中有关排列组合的api"><a href="#stl中有关排列组合的api" class="headerlink" title="stl中有关排列组合的api"></a>stl中有关排列组合的api</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">//func();</span><br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next_permutation</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()));<br></code></pre></td></tr></table></figure><h4 id="lower-bound-amp-amp-upper-bound"><a href="#lower-bound-amp-amp-upper-bound" class="headerlink" title="lower_bound &amp;&amp; upper_bound"></a>lower_bound &amp;&amp; upper_bound</h4><p>lower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找元素的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在从小到大的排序数组中,以vector&lt;int&gt; nums为例子</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><span class="hljs-type">int</span> idx = <span class="hljs-built_in">lower_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target) - nums.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> idx = <span class="hljs-built_in">upper_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target) - nums.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-comment">//在从大到小的排序数组中，重载lower_bound()和upper_bound()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">lower_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">upper_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure><h4 id="能读入空格和回车符的输入方式"><a href="#能读入空格和回车符的输入方式" class="headerlink" title="能读入空格和回车符的输入方式"></a>能读入空格和回车符的输入方式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s;<br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> (cin.<span class="hljs-built_in">peek</span>() != EOF) &#123;<br>    c = cin.<span class="hljs-built_in">get</span>();<br>    s += c;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
