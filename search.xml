<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bfs/Dfs</title>
    <url>/2022/10/09/Bfs:Dfs/</url>
    <content><![CDATA[<h2 id="Bfs-x2F-Dfs"><a href="#Bfs-x2F-Dfs" class="headerlink" title="Bfs&#x2F;Dfs"></a>Bfs&#x2F;Dfs</h2><span id="more"></span>

<h3 id="Dfs"><a href="#Dfs" class="headerlink" title="Dfs"></a>Dfs</h3><h4 id="组合总和-II"><a href="#组合总和-II" class="headerlink" title="组合总和 II"></a>组合总和 II</h4><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用 一次 。</p>
<p>注意：解集不能包含重复的组合。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; t;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(t);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[i] &lt;= target; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; index &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            t.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">dfs</span>(target - nums[i], i + <span class="hljs-number">1</span>);<br>            t.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        nums = candidates;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">dfs</span>(target,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h4><img src="/2022/10/09/Bfs:Dfs/L695.png" class>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> max_x;<br>    <span class="hljs-type">int</span> max_y;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= max_x || y &gt;= max_y || grid[y][x] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        grid[y][x] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>            <span class="hljs-type">int</span> next_y = y + dy[k];<br>            <span class="hljs-type">int</span> next_x = x + dx[k];<br>            ans += <span class="hljs-built_in">dfs</span>(grid, next_y, next_x);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> area = <span class="hljs-number">0</span>;<br>        max_y = grid.<span class="hljs-built_in">size</span>();<br>        max_x =  grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; max_y; i++) &#123;<br>            <span class="hljs-keyword">for</span>  (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; max_x; j++) &#123;<br>                area = <span class="hljs-built_in">max</span>(area, <span class="hljs-built_in">dfs</span>(grid, i, j));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> area;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">outOfRange</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> y &lt; <span class="hljs-number">0</span> || y &gt;= m || x &lt; <span class="hljs-number">0</span> || x &gt;= n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        grid[y][x] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> ty = y + dy[i];<br>            <span class="hljs-type">int</span> tx = x + dx[i];<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">outOfRange</span>(ty, tx) &amp;&amp; grid[ty][tx] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                <span class="hljs-built_in">dfs</span>(grid, ty, tx);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        m = grid.<span class="hljs-built_in">size</span>();<br>        n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    ans++;<br>                    <span class="hljs-built_in">dfs</span>(grid, i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h4><p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 <strong>遵循如下规则</strong>：</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li>
</ol>
<p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p>
<img src="/2022/10/09/Bfs:Dfs/1.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[][] row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[][] col = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[][][] block = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> List&lt;<span class="hljs-type">int</span>[]&gt; spaces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solveSudoku</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    spaces.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;i, j&#125;);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">dight</span> <span class="hljs-operator">=</span> board[i][j] - <span class="hljs-string">&#x27;0&#x27;</span> - <span class="hljs-number">1</span>;<br>                    Fill(i, j, dight, <span class="hljs-literal">true</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        dfs(board, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Fill</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> dight, <span class="hljs-type">boolean</span> target)</span> &#123;<br>        row[i][dight] = target;<br>        col[j][dight] = target;<br>        block[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>][dight] = target;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> pos)</span> &#123;<br>        <span class="hljs-keyword">if</span> (pos == spaces.size()) &#123;<br>            valid = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">space</span> <span class="hljs-operator">=</span> spaces.get(pos);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> space[<span class="hljs-number">0</span>], j = space[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">dight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; dight &lt; <span class="hljs-number">9</span> &amp;&amp; !valid; dight++) &#123;<br>            <span class="hljs-keyword">if</span> (!row[i][dight] &amp;&amp; !col[j][dight] &amp;&amp; !block[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>][dight]) &#123;<br>                Fill(i, j, dight, <span class="hljs-literal">true</span>);<br>                board[i][j] = (<span class="hljs-type">char</span>)(dight + <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-number">1</span>);<br>                dfs(board, pos + <span class="hljs-number">1</span>);<br>                Fill(i, j, dight, <span class="hljs-literal">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Bfs"><a href="#Bfs" class="headerlink" title="Bfs"></a>Bfs</h3><h4 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h4><img src="/2022/10/09/Bfs:Dfs/L116.png" class>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* left;</span><br><span class="hljs-comment">    Node* right;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span><br><span class="hljs-comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        queue&lt;Node*&gt; Q;<br>        Q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = Q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                Node* node = Q.<span class="hljs-built_in">front</span>();<br>                Q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (i &lt; size - <span class="hljs-number">1</span>) &#123;<br>                    node-&gt;next = Q.<span class="hljs-built_in">front</span>();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>                    Q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>                    Q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="图像渲染"><a href="#图像渲染" class="headerlink" title="图像渲染"></a>图像渲染</h4><p>有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。</p>
<p>你也被给予三个整数 sr ,  sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。</p>
<p>为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。</p>
<p>最后返回 经过上色渲染后的图像 。</p>
<img src="/2022/10/09/Bfs:Dfs/L733.png" class>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">floodFill</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; image, <span class="hljs-type">int</span> sr, <span class="hljs-type">int</span> sc, <span class="hljs-type">int</span> newColor) &#123;<br>        <span class="hljs-type">int</span> currColor = image[sr][sc];<br>        <span class="hljs-keyword">if</span> (currColor == newColor) <span class="hljs-keyword">return</span> image;<br>        <span class="hljs-type">int</span> n = image.<span class="hljs-built_in">size</span>(), m = image[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>        que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(sr, sc)); <span class="hljs-comment">//使用make_pair</span><br>        image[sr][sc] = newColor;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> x = que.<span class="hljs-built_in">front</span>().first, y = que.<span class="hljs-built_in">front</span>().second;<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-type">int</span> mx = x + dx[i], my = y + dy[i];<br>                <span class="hljs-keyword">if</span> (mx &gt;= <span class="hljs-number">0</span> &amp;&amp; mx &lt; n &amp;&amp; my &gt;= <span class="hljs-number">0</span> &amp;&amp; my &lt; m &amp;&amp; image[mx][my] == currColor) &#123;<br>                    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(mx,my));<br>                    image[mx][my] = newColor;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h4><p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：</p>
<p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。</p>
<p>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-type">int</span> max_y = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> max_x = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; Q;<br>        <span class="hljs-type">int</span> minute = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> time[max_y][max_x];<span class="hljs-comment">//橘子腐烂需要的时间</span><br>        <span class="hljs-built_in">memset</span>(time, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(time));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; max_y; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; max_x; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">2</span>) &#123;<br>                    Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i, j));<br>                    time[i][j] = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>()) &#123;<br>            pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; t = Q.<span class="hljs-built_in">front</span>();<br>            Q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                <span class="hljs-type">int</span> x = t.second + dx[i];<br>                <span class="hljs-type">int</span> y = t.first + dy[i];<br>                <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; max_x &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; max_y &amp;&amp; grid[y][x] == <span class="hljs-number">1</span>) &#123;<br>                    grid[y][x] = <span class="hljs-number">2</span>;<br>                    Q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(y, x));<br>                    time[y][x] = time[t.first][t.second] + <span class="hljs-number">1</span>;<br>                    cnt--;<br>                    minute = time[y][x];<br>                &#125;<br>            &#125;<br>                            <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> cnt != <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : minute;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Double Pointer</title>
    <url>/2022/10/09/Double-Pointer/</url>
    <content><![CDATA[<h3 id="Double-Pointer"><a href="#Double-Pointer" class="headerlink" title="Double Pointer"></a>Double Pointer</h3><span id="more"></span>

<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p><code>sort</code></p>
<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请</p>
<p>你返回所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> i,j,k;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            j = i + <span class="hljs-number">1</span>;<br>            k = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>                <span class="hljs-type">int</span> temp = nums[i] + nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span>) &#123;<br>                    j++;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp &gt; <span class="hljs-number">0</span>) &#123;<br>                    k--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);<br>                    j++;<br>                    k--;<br>                    <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>]) j++;<br>                    <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k+<span class="hljs-number">1</span>]) k--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Disjoint Set Union</title>
    <url>/2022/11/03/Disjoint-Set-Union/</url>
    <content><![CDATA[<h2 id="Disjoint-Set-Union"><a href="#Disjoint-Set-Union" class="headerlink" title="Disjoint Set Union"></a>Disjoint Set Union</h2><span id="more"></span>

<h2 id="小蓝鲸分组"><a href="#小蓝鲸分组" class="headerlink" title="小蓝鲸分组"></a>小蓝鲸分组</h2><p>小蓝鲸要去旅游，现在要将他们分成任意大小的 <strong>两组</strong>。由于，每个小蓝鲸都有可能不喜欢其他小蓝鲸，这样的两个小蓝鲸不应该分到一个组里。</p>
<p>现在需要你来判断给定的 n 个小蓝鲸(编号为1, 2 ..，n)是否能成功的分到两个组中。（提示：本题要采用并查集的方法）</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入 n 、 k ，分别表示小蓝鲸的个数和不能分在同一组的小蓝鲸对数</p>
<p>接下来 k 行每行两个整数，代表小蓝鲸的编号</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行，若能成功分为两组则输出 true， 否则输出 false</p>
<h4 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

<p>解释：</p>
<p>第一个组为[1, 4]，</p>
<p>第二个组为[2, 3]。</p>
<h4 id="样例2"><a href="#样例2" class="headerlink" title="样例2"></a>样例2</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10005</span><br><span class="hljs-type">int</span> a[N][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> pre[N];<br><span class="hljs-comment">//改进查找算法：完成路径压缩，将 x的上级直接变为根结点，那么树的高度就会大大降低</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(pre[x] == x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-comment">//先找到根结点 root[x]，然后 pre[x]=root[x]</span><br>    <span class="hljs-keyword">return</span> pre[x] = <span class="hljs-built_in">find</span>(pre[x]);<br>&#125;<br><span class="hljs-comment">//判断两个结点是否连通</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> rootx = <span class="hljs-built_in">find</span>(x);<br>    <span class="hljs-type">int</span> rooty = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(rootx != rooty) pre[rootx] = rooty;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) cin &gt;&gt; a[i][<span class="hljs-number">0</span>] &gt;&gt; a[i][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) pre[i] = i;<br>    <span class="hljs-comment">//确立两个不一样的根</span><br>    <span class="hljs-type">int</span> r1 = a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], r2 = a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSame</span>(a[i][<span class="hljs-number">0</span>], r1)) &#123;<br>            <span class="hljs-built_in">join</span>(a[i][<span class="hljs-number">1</span>], r2);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSame</span>(a[i][<span class="hljs-number">0</span>], r2)) &#123;<br>            <span class="hljs-built_in">join</span>(a[i][<span class="hljs-number">1</span>], r1);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSame</span>(a[i][<span class="hljs-number">1</span>], r1)) &#123;<br>            <span class="hljs-built_in">join</span>(a[i][<span class="hljs-number">0</span>], r2);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSame</span>(a[i][<span class="hljs-number">1</span>], r2)) &#123;<br>            <span class="hljs-built_in">join</span>(a[i][<span class="hljs-number">0</span>], r1);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">join</span>(a[i][<span class="hljs-number">0</span>], r1);<br>            <span class="hljs-built_in">join</span>(a[i][<span class="hljs-number">1</span>], r2);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSame</span>(a[i][<span class="hljs-number">0</span>], a[i][<span class="hljs-number">1</span>])) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;false&quot;</span>;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;true&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Greedy</title>
    <url>/2022/10/12/Greedy/</url>
    <content><![CDATA[<h3 id="Greedy"><a href="#Greedy" class="headerlink" title="Greedy"></a>Greedy</h3><span id="more"></span>

<h4 id="最多重叠区间的区间数量"><a href="#最多重叠区间的区间数量" class="headerlink" title="最多重叠区间的区间数量"></a>最多重叠区间的区间数量</h4><p>给定一个数字m，和m组区间</p>
<p>输出具有最多重叠区间的区间数量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> m;<br>    cin &gt;&gt; m;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">v</span>(m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)  cin &gt;&gt; v[i].first &gt;&gt; v[i].second;<br>    <span class="hljs-keyword">auto</span> cmp = [](pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p1, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p2) &#123;<br>        <span class="hljs-keyword">return</span> p1.second &lt; p2.second;<br>    &#125;;<br>    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, cur = v[<span class="hljs-number">0</span>].second, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : v) &#123;<br>        <span class="hljs-keyword">if</span> (p.first &gt; cur) &#123; <span class="hljs-comment">//此处是闭区间的情况，如果是开区间那么则是&gt;=</span><br>            cur = p.second;<br>            ans = <span class="hljs-built_in">max</span>(ans,cnt);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cnt++;<br>        &#125;<br>    &#125;<br>    ans = <span class="hljs-built_in">max</span>(ans, cnt);<br><br>    cout &lt;&lt; ans;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>这道题目的变式：</p>
<h4 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h4><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>xstart</code>，<code>xend</code>， 且满足  <code>xstart ≤ x ≤ xend</code>，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数</em> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (points.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; u, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; v) &#123;<br>            <span class="hljs-keyword">return</span> u[<span class="hljs-number">1</span>] &lt; v[<span class="hljs-number">1</span>];<br>        &#125;);<br>        <span class="hljs-type">int</span> pos = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; balloon: points) &#123;<br>            <span class="hljs-keyword">if</span> (balloon[<span class="hljs-number">0</span>] &gt; pos) &#123;<br>                pos = balloon[<span class="hljs-number">1</span>];<br>                ++ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Data Structure</title>
    <url>/2022/10/09/Data-Structure/</url>
    <content><![CDATA[<p>Binary-Tree, HashMap, Stack</p>
<span id="more"></span>

<h3 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary-Tree"></a>Binary-Tree</h3><h4 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h4><p>给你两棵二叉树： root1 和 root2 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p>注意: 合并过程必须从两个树的根节点开始。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">nullptr</span> &amp;&amp; root2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span> (root2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root1;<br>        root1-&gt;val += root2-&gt;val;<br>        <br>        root1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);<br>        root1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);<br><br>        <span class="hljs-keyword">return</span> root1;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h4><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; index;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> pre_l, <span class="hljs-type">int</span> pre_r, <span class="hljs-type">int</span> in_l, <span class="hljs-type">int</span> in_r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pre_l &gt; pre_r) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> pre_root = pre_l;<br>        <span class="hljs-type">int</span> in_root = index[preorder[pre_root]];<br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[pre_root]);<br>        <span class="hljs-type">int</span> left_subtree_size = in_root - in_l;<br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(preorder, inorder, pre_l + <span class="hljs-number">1</span>, pre_l + left_subtree_size, in_l, in_root - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(preorder, inorder, pre_l + left_subtree_size + <span class="hljs-number">1</span>, pre_r, in_root + <span class="hljs-number">1</span>, in_r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = preorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) index[inorder[i]] = i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h4><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">construct_paths</span><span class="hljs-params">(TreeNode* root, string path, vector&lt;string&gt;&amp; paths)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">nullptr</span>) &#123;<br>            path += <span class="hljs-built_in">to_string</span>(root-&gt;val);<br>            <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;  <br>                paths.<span class="hljs-built_in">push_back</span>(path);                      <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                path += <span class="hljs-string">&quot;-&gt;&quot;</span>;  <span class="hljs-comment">// 当前节点不是叶子节点，继续递归遍历</span><br>                <span class="hljs-built_in">construct_paths</span>(root-&gt;left, path, paths);<br>                <span class="hljs-built_in">construct_paths</span>(root-&gt;right, path, paths);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;string&gt; paths;<br>        <span class="hljs-built_in">construct_paths</span>(root, <span class="hljs-string">&quot;&quot;</span>, paths);<br>        <span class="hljs-keyword">return</span> paths;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>使用string path来记录过程，简化回溯过程</p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(root-&gt;left), <span class="hljs-built_in">height</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">height</span>(root-&gt;left) - <span class="hljs-built_in">height</span>(root-&gt;right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h3><h4 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h4><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p>
<p>换句话说，s1 的排列之一是 s2 的 子串 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s1.<span class="hljs-built_in">length</span>(), m = s2.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span> (n &gt; m) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt1</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span>, <span class="hljs-title">cnt2</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ++cnt1[s1[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            ++cnt2[s2[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt1 == cnt2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &lt; m; ++i) &#123;<br>            ++cnt2[s2[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            --cnt2[s2[i - n] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (cnt1 == cnt2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><h4 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h4><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>() || c != st.<span class="hljs-built_in">back</span>()) &#123;<br>                st.<span class="hljs-built_in">push_back</span>(c);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>利用cpp的string来模拟stack</p>
<h4 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h4><p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437"> 逆波兰表示法</a>，求表达式的值。</p>
<p>有效的算符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p><strong>注意</strong> 两个整数之间的除法只保留整数部分。</p>
<p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//由于官方改数据，所以要使用long long</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tokens.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;+&quot;</span> || tokens[i] == <span class="hljs-string">&quot;-&quot;</span> || tokens[i] == <span class="hljs-string">&quot;*&quot;</span> || tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>                <span class="hljs-comment">//注意两个操作数的出栈顺序</span><br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> op2 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> op1 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;+&quot;</span>) st.<span class="hljs-built_in">push</span>(op1 + op2);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;-&quot;</span>) st.<span class="hljs-built_in">push</span>(op1 - op2);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;*&quot;</span>) st.<span class="hljs-built_in">push</span>(op1 * op2);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) st.<span class="hljs-built_in">push</span>(op1 / op2);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoll</span>(tokens[i]));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> result = st.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Math</title>
    <url>/2022/10/17/Math/</url>
    <content><![CDATA[<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><span id="more"></span>

<h4 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h4><p><code>Hashset</code></p>
<p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p><strong>「快乐数」</strong> 定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li>
<li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            ans += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-built_in">getNum</span>(n);<br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//说明这个数字已经出现过了</span><br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(sum) != s.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            s.<span class="hljs-built_in">insert</span>(sum);<br>            n = sum;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Other Algorithm</title>
    <url>/2022/10/09/Other-Algorithm/</url>
    <content><![CDATA[<p>快速幂</p>
<span id="more"></span>

<h3 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a>Pow(x, n)</h3><p>实现pow(x, n) ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myMul</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        <span class="hljs-type">double</span> y = <span class="hljs-built_in">myMul</span>(x, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? y * y : y * y * x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> exp = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) n;<br>        <span class="hljs-comment">//考虑到n是负数的情况</span><br>        <span class="hljs-keyword">return</span> exp &gt;= <span class="hljs-number">0</span> ? <span class="hljs-built_in">myMul</span>(x, exp) : <span class="hljs-number">1.0</span> / <span class="hljs-built_in">myMul</span>(x, -exp);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Prefix Add</title>
    <url>/2022/10/15/Prefix-Add/</url>
    <content><![CDATA[<h3 id="Prefix-Add"><a href="#Prefix-Add" class="headerlink" title="Prefix-Add"></a>Prefix-Add</h3><span id="more"></span>

<h4 id="最大和子矩阵"><a href="#最大和子矩阵" class="headerlink" title="最大和子矩阵"></a>最大和子矩阵</h4><p>给定一个n * m的矩阵，找出其中和最大的子矩阵</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> dp[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span> (dp));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-type">int</span> num;<br>            cin &gt;&gt; num;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + num;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//dp[i][j]代表在第j列中从第1行到第i行元素的和</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt;= n; j++)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= m; k++)&#123;<br>                sum = sum + (dp[j][k] - dp[i<span class="hljs-number">-1</span>][k]);<br>                <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-number">0</span>) sum = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(sum &gt; ans) ans = sum;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br><br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Dp</title>
    <url>/2022/10/09/Dp/</url>
    <content><![CDATA[<h3 id="Dp"><a href="#Dp" class="headerlink" title="Dp"></a>Dp</h3><span id="more"></span>

<h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-type">bool</span> dp[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            dp[i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> maxlen = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">2</span>; l &lt;= n; l++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-type">int</span> j = l + i - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (j &gt;= n) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (s[i] != s[j]) &#123;<br>                    dp[i][j] = <span class="hljs-literal">false</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = (j - i &lt; <span class="hljs-number">3</span>) ? <span class="hljs-literal">true</span> : dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxlen) &#123;<br>                        maxlen = j - i + <span class="hljs-number">1</span>;<br>                        begin = i;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(begin, maxlen);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h4><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> dp[n];<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<span class="hljs-comment">//dp[i] means the longest valid bracket list which ends with index of i</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] += (i &gt;= <span class="hljs-number">2</span> ? dp[i<span class="hljs-number">-2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (i - dp[i<span class="hljs-number">-1</span>] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i - dp[i<span class="hljs-number">-1</span>] - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (i - dp[i<span class="hljs-number">-1</span>] - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>                            dp[i] = (dp[i - dp[i<span class="hljs-number">-1</span>] - <span class="hljs-number">2</span>] ? dp[i - dp[i<span class="hljs-number">-1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <br>            ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>





<h4 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> dp[n];<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这道题是非常经典的dp入门题，对于相邻状态的处理有非常好的理解作用</p>
<h4 id="删除并获得点数"><a href="#删除并获得点数" class="headerlink" title="删除并获得点数"></a>删除并获得点数</h4><p>给你一个整数数组 nums ，你可以对它进行一些操作。</p>
<p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p>
<p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> first = nums[<span class="hljs-number">0</span>], second = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-type">int</span> temp = second;<br>            second = <span class="hljs-built_in">max</span>(first + nums[i], second);<br>            first = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> second;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteAndEarn</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxVal = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : nums) &#123;<br>            maxVal = <span class="hljs-built_in">max</span>(maxVal, val);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(maxVal + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : nums) &#123;<br>            sum[val] += val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rob</span>(sum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>注意这道题目用到了打家劫舍的模型</p>
<h4 id="环形子数组的最大和-Kanade-算法"><a href="#环形子数组的最大和-Kanade-算法" class="headerlink" title="环形子数组的最大和(Kanade 算法)"></a>环形子数组的最大和(Kanade 算法)</h4><img src="/2022/10/09/Dp/L918.png" class>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A)</span> </span>&#123;<br>    <span class="hljs-comment">//统一注释，total为数组的总和，maxSum为最大子数组和，minSum为最小子数组和，curMax为包含当前元素的最大子数组和，curMin为包含当前元素的最小子数组和</span><br>        <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>, maxSum = A[<span class="hljs-number">0</span>], curMax = <span class="hljs-number">0</span>, minSum = A[<span class="hljs-number">0</span>], curMin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) &#123;<br>            curMax = <span class="hljs-built_in">max</span>(curMax + a, a);<br>            maxSum = <span class="hljs-built_in">max</span>(maxSum, curMax);<br>            curMin = <span class="hljs-built_in">min</span>(curMin + a, a);<br>            minSum = <span class="hljs-built_in">min</span>(minSum, curMin);<br>            total += a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxSum &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">max</span>(maxSum, total - minSum) : maxSum;<br>        <span class="hljs-comment">//如果元素都是非正的话,要分类讨论</span><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Sliding Window</title>
    <url>/2022/10/09/Sliding-Window/</url>
    <content><![CDATA[<h3 id="SlidingWindow"><a href="#SlidingWindow" class="headerlink" title="SlidingWindow"></a>SlidingWindow</h3><span id="more"></span>

<h4 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h4><p><code>HashMap</code></p>
<p>给定一个字符串<code>s</code>，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, temp = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hashmap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (hashmap.<span class="hljs-built_in">find</span>(s[i]) == hashmap.<span class="hljs-built_in">end</span>()) &#123;<br>                temp++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp = <span class="hljs-built_in">min</span>(temp + <span class="hljs-number">1</span>, i - hashmap[s[i]]);<br>            &#125;<br>            hashmap[s[i]] = i;<br>            res = <span class="hljs-built_in">max</span>(res, temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h4><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = INT_MAX;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (end &lt; n) &#123;<br>            sum += nums[end];<br>            <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;<br>                ans = <span class="hljs-built_in">min</span>(ans, end - start + <span class="hljs-number">1</span>);<br>                sum -= nums[start];<br>                start++;<br>            &#125;<br>            end++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == INT_MAX ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="水果成篮"><a href="#水果成篮" class="headerlink" title="水果成篮"></a>水果成篮</h4><p><code>Hashmap</code></p>
<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<ul>
<li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li>
<li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li>
<li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li>
</ul>
<p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fruits)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = fruits.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt; n; r++) &#123;<br>            ++cnt[fruits[r]];<br>            <span class="hljs-keyword">while</span> ((<span class="hljs-type">int</span>)cnt.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">2</span>) &#123;<br>                cnt[fruits[l]]--;<br>                <span class="hljs-keyword">if</span> (cnt[fruits[l]] == <span class="hljs-number">0</span>) cnt.<span class="hljs-built_in">erase</span>(fruits[l]);<br>                l++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, r - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>cpp header</title>
    <url>/2022/10/04/cpp-header/</url>
    <content><![CDATA[<p>由于在上机考试的时候编辑器的原因，在这里整理了一些常用函数以及需要的头文件</p>
<span id="more"></span>

<h3 id="include-lt-algorithm-gt"><a href="#include-lt-algorithm-gt" class="headerlink" title="#include  &lt;algorithm&gt;"></a>#include  &lt;algorithm&gt;</h3><h4 id="max-min-abs"><a href="#max-min-abs" class="headerlink" title="max(),min(),abs()"></a>max(),min(),abs()</h4><p><code>abs()</code>函数只能用于求整型变量的绝对值，而<code>#include&lt;cmath&gt;</code>中的<code>fabs()</code>函数还可用于求浮点型变量的绝对值，不要搞混~</p>
<h4 id="交换函数：swap"><a href="#交换函数：swap" class="headerlink" title="交换函数：swap()"></a>交换函数：swap()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">( T&amp; a, T&amp; b )</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="翻转函数：reverse"><a href="#翻转函数：reverse" class="headerlink" title="翻转函数：reverse()"></a>翻转函数：reverse()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(BidirIt first, BidirIt last )</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="排序函数：sort"><a href="#排序函数：sort" class="headerlink" title="排序函数：sort()"></a>排序函数：sort()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs Cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">( RandomIt first, RandomIt last )</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">( RandomIt first, RandomIt last, Compare comp )</span></span>;<br><br><span class="hljs-comment">//从小到大</span><br>std::<span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">//从大到小</span><br>std::<span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure>

<h4 id="查找函数：find-、upper-bound-、lower-bound"><a href="#查找函数：find-、upper-bound-、lower-bound" class="headerlink" title="查找函数：find()、upper_bound()、lower_bound()"></a>查找函数：find()、upper_bound()、lower_bound()</h4><p>find在string, map, set中可以用，在vector中不可以用</p>
<p>upper_bound, lower_bound在数组和vector中常用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**Returns an iterator pointing to the first element in the range [first, last) that does not satisfy element &lt; value (or comp(element, value)), (i.e. greater or equal to), or last if no such element is found.</span><br><span class="hljs-comment">**/</span><br><span class="hljs-function">ForwardIt <span class="hljs-title">lower_bound</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br><br><span class="hljs-function">ForwardIt <span class="hljs-title">upper_bound</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="查找某值出现的次数：count"><a href="#查找某值出现的次数：count" class="headerlink" title="查找某值出现的次数：count()"></a>查找某值出现的次数：count()</h4><p>count在string, map, set中可以用，在vector中不可以用</p>
<h3 id="include-lt-cstring-gt"><a href="#include-lt-cstring-gt" class="headerlink" title="#include &lt;cstring&gt;"></a>#include &lt;cstring&gt;</h3><h4 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *s, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> n)</span></span>; <br></code></pre></td></tr></table></figure>

<h3 id="include-lt-string-gt"><a href="#include-lt-string-gt" class="headerlink" title="#include  &lt;string&gt;"></a>#include  &lt;string&gt;</h3><h4 id="stoi-stol-stoll"><a href="#stoi-stol-stoll" class="headerlink" title="stoi(),stol(),stoll()"></a>stoi(),stol(),stoll()</h4><p>转化之前会进行范围检查，如果发现超出范围会发出 runtime error!</p>
<p>converts a string to a signed integer </p>
<h4 id="stof-stod"><a href="#stof-stod" class="headerlink" title="stof(),stod()"></a>stof(),stod()</h4><p>converts a string to a floating point value </p>
<h4 id="to-string"><a href="#to-string" class="headerlink" title="to_string()"></a>to_string()</h4><p>converts an integral or floating point value to string</p>
<h4 id="find-find-first-of"><a href="#find-find-first-of" class="headerlink" title="find(), find_first_of()"></a>find(), find_first_of()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">size_type <span class="hljs-title">find</span><span class="hljs-params">( <span class="hljs-type">const</span> basic_string&amp; str, size_type pos = <span class="hljs-number">0</span> )</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">size_type <span class="hljs-title">find_first_of</span><span class="hljs-params">( <span class="hljs-type">const</span> basic_string&amp; str, size_type pos = <span class="hljs-number">0</span> )</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">//返回值：如果查找成功，则返回查找到的子字符串第一个字符的位置；否则返回string::npos</span><br></code></pre></td></tr></table></figure>

<h4 id="erase"><a href="#erase" class="headerlink" title="erase()"></a>erase()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(iterator p)</span></span>; <span class="hljs-comment">//删除p指向的字符</span><br><span class="hljs-function">string&amp; <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos=<span class="hljs-number">0</span>, <span class="hljs-type">size_t</span> len = npos)</span> <span class="hljs-comment">//删除从pos开始，长度为len的子串</span></span><br></code></pre></td></tr></table></figure>

<h3 id="include-lt-sstream-gt"><a href="#include-lt-sstream-gt" class="headerlink" title="#include &lt;sstream&gt;"></a>#include &lt;sstream&gt;</h3><h4 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">string s = <span class="hljs-string">&quot;ab cd 123 abcde&quot;</span>;<br><span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(s)</span></span>;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>cpp tips</title>
    <url>/2022/09/29/cpp-tips/</url>
    <content><![CDATA[<p>这篇博客整理了自己学习cpp过程中遇到的一些小技巧和想法，会持续更新</p>
<span id="more"></span>

<h4 id="cpp删除容器中重复元素的方法："><a href="#cpp删除容器中重复元素的方法：" class="headerlink" title="cpp删除容器中重复元素的方法："></a>cpp删除容器中重复元素的方法：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">a.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>()),a.<span class="hljs-built_in">end</span>())；<br></code></pre></td></tr></table></figure>

<h4 id="stl中有关排列组合的api"><a href="#stl中有关排列组合的api" class="headerlink" title="stl中有关排列组合的api"></a>stl中有关排列组合的api</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">//func();</span><br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next_permutation</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()));<br></code></pre></td></tr></table></figure>

<h4 id="lower-bound-amp-amp-upper-bound"><a href="#lower-bound-amp-amp-upper-bound" class="headerlink" title="lower_bound &amp;&amp; upper_bound"></a>lower_bound &amp;&amp; upper_bound</h4><p>lower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找元素的方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在从小到大的排序数组中,以vector&lt;int&gt; nums为例子</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><span class="hljs-type">int</span> idx = <span class="hljs-built_in">lower_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target) - nums.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> idx = <span class="hljs-built_in">upper_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target) - nums.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-comment">//在从大到小的排序数组中，重载lower_bound()和upper_bound()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">lower_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">upper_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure>

<h4 id="循环中的格式化输出"><a href="#循环中的格式化输出" class="headerlink" title="循环中的格式化输出"></a>循环中的格式化输出</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>		cout &lt;&lt; mat[i][j] &lt;&lt; (j &lt; n - <span class="hljs-number">1</span> ? <span class="hljs-string">&quot; &quot;</span> : <span class="hljs-string">&quot;\n&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="I-x2F-0技巧"><a href="#I-x2F-0技巧" class="headerlink" title="I&#x2F;0技巧"></a>I&#x2F;0技巧</h3><h4 id="能读入空格和回车符的输入方式"><a href="#能读入空格和回车符的输入方式" class="headerlink" title="能读入空格和回车符的输入方式"></a>能读入空格和回车符的输入方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string s;<br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> (cin.<span class="hljs-built_in">get</span>()) &#123;<br>    s += c;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="读入一个整数之后再读入行"><a href="#读入一个整数之后再读入行" class="headerlink" title="读入一个整数之后再读入行"></a>读入一个整数之后再读入行</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br>cin &gt;&gt; ws;<br>string t;<br><span class="hljs-built_in">getline</span>(cin, t);<br></code></pre></td></tr></table></figure>

<h4 id="输入未知个数的数字"><a href="#输入未知个数的数字" class="headerlink" title="输入未知个数的数字"></a>输入未知个数的数字</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>	<span class="hljs-built_in">func</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="输入未知个数的字符和字符串"><a href="#输入未知个数的字符和字符串" class="headerlink" title="输入未知个数的字符和字符串"></a>输入未知个数的字符和字符串</h4><p>此处以字符串为例子，cin会跳过空格以及换行符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">string s;<br>vector&lt;string&gt; v;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123;<br>    v.<span class="hljs-built_in">push_back</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="读入一行以空格分割的字符串"><a href="#读入一行以空格分割的字符串" class="headerlink" title="读入一行以空格分割的字符串"></a>读入一行以空格分割的字符串</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split</span><span class="hljs-params">(string s, <span class="hljs-type">char</span> seq)</span> </span>&#123;<br>    <span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(s)</span></span>;<br>    vector&lt;string&gt; ans;<br>    string temp;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ss, temp, seq)) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(temp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    string s;<br>    <span class="hljs-built_in">getline</span>(cin, s);<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">strs</span><span class="hljs-params">(split(s, <span class="hljs-string">&#x27; &#x27;</span>))</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>cpp 坑</title>
    <url>/2022/10/04/cpp-%E5%9D%91/</url>
    <content><![CDATA[<p>这篇博客整理了自己在学习cpp时踩的一些坑……</p>
<span id="more"></span>

<h4 id="头文件中的模板类编译时的一个坑及其原因"><a href="#头文件中的模板类编译时的一个坑及其原因" class="headerlink" title="头文件中的模板类编译时的一个坑及其原因"></a>头文件中的模板类编译时的一个坑及其原因</h4><p>如果把模板类的声明和定义都放在头文件中。需要用到模板类的时候，只需要包含该头文件，然后进行实例化。</p>
<p>如果模板类的声明和定义分别放在头文件和源文件中。当实例化的时候，只包含头文件会发证链接错误。</p>
<p>原因是模板类的实例化要分成两个步骤，模板的特例化和特例的实例化。</p>
<p>编译器在编译阶段，由于没有定义，所以编译器不能生成具体的模板特例，但是这并不会报错误，编译器将把问题抛给链接器来做。在编译源文件的时候，程序找不到该模板的特例，只是有模板而已，所以无法生成对象。所以会发生错误。</p>
<h4 id="string-substr-int-a-int-b"><a href="#string-substr-int-a-int-b" class="headerlink" title="string.substr(int a, int b);"></a>string.substr(int a, int b);</h4><p>注意b不是末尾下标，a是选取的首字母下标，b是选取字符串的长度</p>
<h4 id="数组a-n-中a在函数传递的理解"><a href="#数组a-n-中a在函数传递的理解" class="headerlink" title="数组a[n]中a在函数传递的理解"></a>数组a[n]中a在函数传递的理解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-comment">//在参数传递的过程中，a传递的是a[0]的地址，一定要传递数组个数n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(a) / <span class="hljs-built_in">sizeof</span>(a[<span class="hljs-number">0</span>]); i++) &#123;<br>        cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//此时是执行不了的！！！</span><br>&#125;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">6</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) a[i] = i;<br><span class="hljs-built_in">f</span>(a, <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure>

<h4 id="cpp是没有越界检查的"><a href="#cpp是没有越界检查的" class="headerlink" title="cpp是没有越界检查的"></a>cpp是没有越界检查的</h4><p>“烫”的出现原因</p>
<h4 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h4><p>memset初始化的值只能为0和-1（二进制为全0和全1）</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>Graph</title>
    <url>/2022/10/24/Graph/</url>
    <content><![CDATA[<h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><span id="more"></span>

<h4 id="所有可能的路径"><a href="#所有可能的路径" class="headerlink" title="所有可能的路径"></a>所有可能的路径</h4><p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p>
<p> <code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p>
<img src="/2022/10/24/Graph/1.jpg" class>

<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]<br>输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]<br></code></pre></td></tr></table></figure>

<h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph, <span class="hljs-type">int</span> node, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; paths)</span> &#123;<br>        path.add(node);<br>        <span class="hljs-keyword">if</span> (node == graph.length - <span class="hljs-number">1</span>) &#123;<br>            paths.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        &#125;<br>        <span class="hljs-type">int</span>[] nextNodes = graph[node];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nextNode : nextNodes) &#123;<br>            dfs(graph, nextNode, path, paths);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">allPathsSourceTarget</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; paths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dfs(graph, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(), paths);<br>        <span class="hljs-keyword">return</span> paths;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">allPathsSourceTarget</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] graph)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; paths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;List&lt;Integer&gt;&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        path.add(<span class="hljs-number">0</span>);<br>        queue.add(path);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            List&lt;Integer&gt; curPath = queue.poll();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> curPath.get(curPath.size() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nextNode : graph[node]) &#123;<br>                List&lt;Integer&gt; tempPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(curPath);<br>                tempPath.add(nextNode);<br>                <span class="hljs-keyword">if</span> (nextNode == graph.length - <span class="hljs-number">1</span>) &#123;<br>                    paths.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tempPath));<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(tempPath));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> paths;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h4><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; edges;<br>    <span class="hljs-type">int</span>[] visited;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites)</span> &#123;<br>        edges = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; ++i) &#123;<br>            edges.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());<br>        &#125;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] info : prerequisites) &#123;<br>            edges.get(info[<span class="hljs-number">1</span>]).add(info[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-number">0</span>) &#123;<br>                dfs(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> valid;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>        visited[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v: edges.get(u)) &#123;<br>            <span class="hljs-keyword">if</span> (visited[v] == <span class="hljs-number">0</span>) &#123;<br>                dfs(v);<br>                <span class="hljs-keyword">if</span> (!valid) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (visited[v] == <span class="hljs-number">1</span>) &#123;<br>                valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        visited[u] = <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2022/10/05/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>许多时候有一些常见的代码模板一直在复用，自己整理一下</p>
<span id="more"></span>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="大数加法"><a href="#大数加法" class="headerlink" title="大数加法"></a>大数加法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">add</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = a.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>, j = b.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>, carry = <span class="hljs-number">0</span>;<br>    string res;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> x = i &gt;= <span class="hljs-number">0</span> ? a[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> y = j &gt;= <span class="hljs-number">0</span> ? b[j] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum = x + y + carry;<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;0&#x27;</span> + sum % <span class="hljs-number">10</span>);<br>        carry = sum / <span class="hljs-number">10</span>;<br>        i--;<br>        j--;<br>    &#125;<br>    <span class="hljs-comment">//注意需要翻转</span><br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title>无法连接本地数据库</title>
    <url>/2022/10/22/%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="IDEA无法连接本地数据库"><a href="#IDEA无法连接本地数据库" class="headerlink" title="IDEA无法连接本地数据库"></a>IDEA无法连接本地数据库</h1><span id="more"></span>

<p>由于重装了一次MySQL（重设密码也折腾了好久），自己在重连的时候一直报如下的bug，找了好久终于找到了问题所在</p>
<img src="/2022/10/22/%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93/1.png" class>

<p>由于IDEA, DG的默认端口号都是3306，但是查找MySQL的端口号发现是0，所以无法连接。（第一次装的时候没出现这个问题，不知道是否是MacOS 13的坑）</p>
<img src="/2022/10/22/%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93/2.png" class>

<p>接下来我们对port进行修改</p>
<p>首先手动关闭MySQL，这里发现关闭多次后仍然显示绿色。那么我们使用终端进行关闭</p>
<img src="/2022/10/22/%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93/3.png" class>

<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mysql -u root -p<br>//输入password之后 (mysql的并非是本地主机root的)<br>shutdown;<br></code></pre></td></tr></table></figure>

<p>如下图就弄好了</p>
<img src="/2022/10/22/%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93/4.png" class>

<p>接下来我们需要找到传说中的mysql配置文件（找了半天还是没找到）</p>
<p>突然，无意间我瞥到了这句评论！！！！</p>
<img src="/2022/10/22/%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93/5.png" class>

<p>我突然想到是不是长时间的MySQL运行（我设置的是开机即打开MySQL)使得端口发生改变，于是我重启MySQL,(在上一步中关闭)</p>
<p>！！！！！！！</p>
<img src="/2022/10/22/%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93/6.png" class>

<p>配置成功！！！！</p>
<p>总结：</p>
<p>感觉如果没必要还是不用开机启动MySQL，使用的时候再启动最好！</p>
]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot基本配置整理</title>
    <url>/2022/10/29/SpringBoot%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="SpringBoot基本配置整理"><a href="#SpringBoot基本配置整理" class="headerlink" title="SpringBoot基本配置整理"></a>SpringBoot基本配置整理</h2><span id="more"></span>

<h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h3><figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">port</span>: <span class="hljs-string">80</span><br><span class="hljs-attr">spring</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">datasource</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">druid</span>:<span class="hljs-string"></span><br>      <span class="hljs-attr">driver-class-name</span>: <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">url</span>: <span class="hljs-string">jdbc:mysql://localhost:3306/todolist?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span><br>      <span class="hljs-attr">username</span>: <span class="hljs-string">root</span><br>      <span class="hljs-attr">password</span>: <span class="hljs-string">123456</span><br><br><span class="hljs-attr">mybatis-plus</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">global-config</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">db-config</span>:<span class="hljs-string"></span><br>      <span class="hljs-attr">table-prefix</span>: <span class="hljs-string">tbl_</span><br>      <span class="hljs-attr">id-type</span>: <span class="hljs-string">auto</span><br>  <span class="hljs-attr">configuration</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">log-impl</span>: <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br><br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
</search>
