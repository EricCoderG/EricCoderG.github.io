<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Double-Pointer</title>
    <url>/2022/10/09/Double-Pointer/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Other-Algorithm</title>
    <url>/2022/10/09/Other-Algorithm/</url>
    <content><![CDATA[<p>快速幂</p>
<span id="more"></span>

<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><h4 id="L50"><a href="#L50" class="headerlink" title="L50"></a>L50</h4><p>实现pow(x, n) ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myMul</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        <span class="hljs-type">double</span> y = <span class="hljs-built_in">myMul</span>(x, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? y * y : y * y * x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> exp = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) n;<br>        <span class="hljs-comment">//考虑到n是负数的情况</span><br>        <span class="hljs-keyword">return</span> exp &gt;= <span class="hljs-number">0</span> ? <span class="hljs-built_in">myMul</span>(x, exp) : <span class="hljs-number">1.0</span> / <span class="hljs-built_in">myMul</span>(x, -exp);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>SlidingWindow</title>
    <url>/2022/10/09/SlidingWindow/</url>
    <content><![CDATA[<h3 id="SlidingWindow"><a href="#SlidingWindow" class="headerlink" title="SlidingWindow"></a>SlidingWindow</h3><span id="more"></span>

<h4 id="L3"><a href="#L3" class="headerlink" title="L3"></a>L3</h4><p><code>HashMap</code></p>
<p>给定一个字符串<code>s</code>，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, temp = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hashmap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (hashmap.<span class="hljs-built_in">find</span>(s[i]) == hashmap.<span class="hljs-built_in">end</span>()) &#123;<br>                temp++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp = <span class="hljs-built_in">min</span>(temp + <span class="hljs-number">1</span>, i - hashmap[s[i]]);<br>            &#125;<br>            hashmap[s[i]] = i;<br>            res = <span class="hljs-built_in">max</span>(res, temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Dp</title>
    <url>/2022/10/09/Dp/</url>
    <content><![CDATA[<h3 id="Dp"><a href="#Dp" class="headerlink" title="Dp"></a>Dp</h3><span id="more"></span>

<h4 id="L32"><a href="#L32" class="headerlink" title="L32"></a>L32</h4><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> dp[n];<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<span class="hljs-comment">//dp[i] means the longest valid bracket list which ends with index of i</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] += (i &gt;= <span class="hljs-number">2</span> ? dp[i<span class="hljs-number">-2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (i - dp[i<span class="hljs-number">-1</span>] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i - dp[i<span class="hljs-number">-1</span>] - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (i - dp[i<span class="hljs-number">-1</span>] - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>                            dp[i] = (dp[i - dp[i<span class="hljs-number">-1</span>] - <span class="hljs-number">2</span>] ? dp[i - dp[i<span class="hljs-number">-1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            dp[i] = dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <br>            ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>





<h4 id="L198"><a href="#L198" class="headerlink" title="L198"></a>L198</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> dp[n];<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这道题是非常经典的dp入门题，对于相邻状态的处理有非常好的理解作用</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Bfs/Dfs</title>
    <url>/2022/10/09/Bfs:Dfs/</url>
    <content><![CDATA[<h3 id="Bfs-x2F-Dfs"><a href="#Bfs-x2F-Dfs" class="headerlink" title="Bfs&#x2F;Dfs"></a>Bfs&#x2F;Dfs</h3><span id="more"></span>

<h4 id="L200"><a href="#L200" class="headerlink" title="L200"></a>L200</h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">outOfRange</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> y &lt; <span class="hljs-number">0</span> || y &gt;= m || x &lt; <span class="hljs-number">0</span> || x &gt;= n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        grid[y][x] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> ty = y + dy[i];<br>            <span class="hljs-type">int</span> tx = x + dx[i];<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">outOfRange</span>(ty, tx) &amp;&amp; grid[ty][tx] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                <span class="hljs-built_in">dfs</span>(grid, ty, tx);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        m = grid.<span class="hljs-built_in">size</span>();<br>        n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    ans++;<br>                    <span class="hljs-built_in">dfs</span>(grid, i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2022/10/05/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>许多时候有一些常见的代码模板一直在复用，自己整理一下</p>
<span id="more"></span>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="大数加法"><a href="#大数加法" class="headerlink" title="大数加法"></a>大数加法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">add</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = a.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>, j = b.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>, carry = <span class="hljs-number">0</span>;<br>    string res;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> x = i &gt;= <span class="hljs-number">0</span> ? a[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> y = j &gt;= <span class="hljs-number">0</span> ? b[j] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum = x + y + carry;<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;0&#x27;</span> + sum % <span class="hljs-number">10</span>);<br>        carry = sum / <span class="hljs-number">10</span>;<br>        i--;<br>        j--;<br>    &#125;<br>    <span class="hljs-comment">//注意需要翻转</span><br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="循环中的格式化输出"><a href="#循环中的格式化输出" class="headerlink" title="循环中的格式化输出"></a>循环中的格式化输出</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>		cout &lt;&lt; mat[i][j] &lt;&lt; (j &lt; n - <span class="hljs-number">1</span> ? <span class="hljs-string">&quot; &quot;</span> : <span class="hljs-string">&quot;\n&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title>cpp-header</title>
    <url>/2022/10/04/cpp-header/</url>
    <content><![CDATA[<p>由于在上机考试的时候编辑器的原因，在这里整理了一些常用函数以及需要的头文件</p>
<span id="more"></span>

<h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *s, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> n)</span></span>; <br></code></pre></td></tr></table></figure>

<h3 id="algorithm-头文件"><a href="#algorithm-头文件" class="headerlink" title="algorithm 头文件"></a>algorithm 头文件</h3><h4 id="max-min-abs"><a href="#max-min-abs" class="headerlink" title="max(),min(),abs()"></a>max(),min(),abs()</h4><p><code>abs()</code>函数只能用于求整型变量的绝对值，而<code>#include&lt;cmath&gt;</code>中的<code>fabs()</code>函数还可用于求浮点型变量的绝对值，不要搞混~</p>
<h4 id="交换函数：swap"><a href="#交换函数：swap" class="headerlink" title="交换函数：swap()"></a>交换函数：swap()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">( T&amp; a, T&amp; b )</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="翻转函数：reverse"><a href="#翻转函数：reverse" class="headerlink" title="翻转函数：reverse()"></a>翻转函数：reverse()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(BidirIt first, BidirIt last )</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="排序函数：sort"><a href="#排序函数：sort" class="headerlink" title="排序函数：sort()"></a>排序函数：sort()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs Cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">( RandomIt first, RandomIt last )</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">( RandomIt first, RandomIt last, Compare comp )</span></span>;<br><br><span class="hljs-comment">//从小到大</span><br>std::<span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">//从大到小</span><br>std::<span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure>

<h4 id="查找函数：find-、upper-bound-、lower-bound"><a href="#查找函数：find-、upper-bound-、lower-bound" class="headerlink" title="查找函数：find()、upper_bound()、lower_bound()"></a>查找函数：find()、upper_bound()、lower_bound()</h4><p>find在string, map, set中可以用，在vector中不可以用</p>
<p>upper_bound, lower_bound在数组和vector中常用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**Returns an iterator pointing to the first element in the range [first, last) that does not satisfy element &lt; value (or comp(element, value)), (i.e. greater or equal to), or last if no such element is found.</span><br><span class="hljs-comment">**/</span><br><span class="hljs-function">ForwardIt <span class="hljs-title">lower_bound</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br><br><span class="hljs-function">ForwardIt <span class="hljs-title">upper_bound</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="填充函数：fill"><a href="#填充函数：fill" class="headerlink" title="填充函数：fill()"></a>填充函数：fill()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fill</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; value )</span></span>; <br></code></pre></td></tr></table></figure>

<p>在区间内填充某一个值。同样<strong>适用所有类型数组，容器</strong>。</p>
<h4 id="查找某值出现的次数：count"><a href="#查找某值出现的次数：count" class="headerlink" title="查找某值出现的次数：count()"></a>查找某值出现的次数：count()</h4><p>count在string, map, set中可以用，在vector中不可以用</p>
<h4 id="求最大公因数：gcd"><a href="#求最大公因数：gcd" class="headerlink" title="求最大公因数：gcd()"></a>求最大公因数：gcd()</h4><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="stoi-stol-stoll"><a href="#stoi-stol-stoll" class="headerlink" title="stoi(),stol(),stoll()"></a>stoi(),stol(),stoll()</h4><p>converts a string to a signed integer </p>
<h4 id="stof-stod"><a href="#stof-stod" class="headerlink" title="stof(),stod()"></a>stof(),stod()</h4><p>converts a string to a floating point value </p>
<h4 id="to-string"><a href="#to-string" class="headerlink" title="to_string()"></a>to_string()</h4><p>converts an integral or floating point value to string</p>
<h4 id="find-find-first-of"><a href="#find-find-first-of" class="headerlink" title="find(), find_first_of()"></a>find(), find_first_of()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">size_type <span class="hljs-title">find</span><span class="hljs-params">( <span class="hljs-type">const</span> basic_string&amp; str, size_type pos = <span class="hljs-number">0</span> )</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">size_type <span class="hljs-title">find_first_of</span><span class="hljs-params">( <span class="hljs-type">const</span> basic_string&amp; str, size_type pos = <span class="hljs-number">0</span> )</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">//返回值：如果查找成功，则返回查找到的子字符串第一个字符的位置；否则返回string::npos</span><br></code></pre></td></tr></table></figure>

<h4 id="erase"><a href="#erase" class="headerlink" title="erase()"></a>erase()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(iterator p)</span></span>; <span class="hljs-comment">//删除p指向的字符</span><br><span class="hljs-function">string&amp; <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos=<span class="hljs-number">0</span>, <span class="hljs-type">size_t</span> len = npos)</span> <span class="hljs-comment">//删除从pos开始，长度为len的子串</span></span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>cpp-坑</title>
    <url>/2022/10/04/cpp-%E5%9D%91/</url>
    <content><![CDATA[<p>这篇博客整理了自己在学习cpp时踩的一些坑……</p>
<span id="more"></span>

<h4 id="头文件中的模板类编译时的一个坑及其原因"><a href="#头文件中的模板类编译时的一个坑及其原因" class="headerlink" title="头文件中的模板类编译时的一个坑及其原因"></a>头文件中的模板类编译时的一个坑及其原因</h4><p>如果把模板类的声明和定义都放在头文件中。需要用到模板类的时候，只需要包含该头文件，然后进行实例化。</p>
<p>如果模板类的声明和定义分别放在头文件和源文件中。当实例化的时候，只包含头文件会发证链接错误。</p>
<p>原因是模板类的实例化要分成两个步骤，模板的特例化和特例的实例化。</p>
<p>编译器在编译阶段，由于没有定义，所以编译器不能生成具体的模板特例，但是这并不会报错误，编译器将把问题抛给链接器来做。在编译源文件的时候，程序找不到该模板的特例，只是有模板而已，所以无法生成对象。所以会发生错误。</p>
<h4 id="string-substr-int-a-int-b"><a href="#string-substr-int-a-int-b" class="headerlink" title="string.substr(int a, int b);"></a>string.substr(int a, int b);</h4><p>注意b不是末尾下标，a是选取的首字母下标，b是选取字符串的长度</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>cpp-tips</title>
    <url>/2022/09/29/cpp-tips/</url>
    <content><![CDATA[<p>这篇博客整理了自己学习cpp过程中遇到的一些小技巧和想法，会持续更新</p>
<span id="more"></span>

<h4 id="cpp删除容器中重复元素的方法："><a href="#cpp删除容器中重复元素的方法：" class="headerlink" title="cpp删除容器中重复元素的方法："></a>cpp删除容器中重复元素的方法：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">a.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>()),a.<span class="hljs-built_in">end</span>())；<br></code></pre></td></tr></table></figure>

<h4 id="stl中有关排列组合的api"><a href="#stl中有关排列组合的api" class="headerlink" title="stl中有关排列组合的api"></a>stl中有关排列组合的api</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">//func();</span><br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next_permutation</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>()));<br></code></pre></td></tr></table></figure>

<h4 id="lower-bound-amp-amp-upper-bound"><a href="#lower-bound-amp-amp-upper-bound" class="headerlink" title="lower_bound &amp;&amp; upper_bound"></a>lower_bound &amp;&amp; upper_bound</h4><p>lower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找元素的方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在从小到大的排序数组中,以vector&lt;int&gt; nums为例子</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><span class="hljs-type">int</span> idx = <span class="hljs-built_in">lower_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target) - nums.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> idx = <span class="hljs-built_in">upper_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target) - nums.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-comment">//在从大到小的排序数组中，重载lower_bound()和upper_bound()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">lower_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">upper_bound</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), target, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure>

<h3 id="I-x2F-0技巧"><a href="#I-x2F-0技巧" class="headerlink" title="I&#x2F;0技巧"></a>I&#x2F;0技巧</h3><h4 id="能读入空格和回车符的输入方式"><a href="#能读入空格和回车符的输入方式" class="headerlink" title="能读入空格和回车符的输入方式"></a>能读入空格和回车符的输入方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string s;<br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> (cin.<span class="hljs-built_in">get</span>()) &#123;<br>    s += c;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="读入一个整数之后再读入行"><a href="#读入一个整数之后再读入行" class="headerlink" title="读入一个整数之后再读入行"></a>读入一个整数之后再读入行</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br>cin &gt;&gt; ws;<br>string t;<br><span class="hljs-built_in">getline</span>(cin, t);<br></code></pre></td></tr></table></figure>

<h4 id="输入未知个数的数字"><a href="#输入未知个数的数字" class="headerlink" title="输入未知个数的数字"></a>输入未知个数的数字</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>	<span class="hljs-built_in">func</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="输入未知个数的字符和字符串"><a href="#输入未知个数的字符和字符串" class="headerlink" title="输入未知个数的字符和字符串"></a>输入未知个数的字符和字符串</h4><p>此处以字符串为例子，cin会跳过空格以及换行符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">string s;<br>vector&lt;string&gt; v;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123;<br>    v.<span class="hljs-built_in">push_back</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
  </entry>
</search>
