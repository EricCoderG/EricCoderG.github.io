<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello-World!</title>
    <url>/2022/09/29/Hello-World/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>欢迎大家来到我的博客！</p>
<p>算是机缘巧合，自己走进了与代码密不可分的世界。</p>
<p>既有满腔热情去探索0与1的奥秘，也对不断迭代，晦涩难懂的技术充满了好奇与敬畏。</p>
<p>这里有我学习生活上的一些想法与总结，希望能够坚持写下去吧。</p>
<span id="more"></span>

<h3 id="个人履历："><a href="#个人履历：" class="headerlink" title="个人履历："></a>个人履历：</h3><p>2021 - 今 ：南京大学软件工程本科</p>
<p>​	</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
  </entry>
  <entry>
    <title>cpp-tips</title>
    <url>/2022/09/29/cpp-tips/</url>
    <content><![CDATA[<p>这篇博客整理了自己学习cpp过程中遇到的一些小技巧和想法，会持续更新</p>
<span id="more"></span>

<h4 id="cpp删除容器中重复元素的方法："><a href="#cpp删除容器中重复元素的方法：" class="headerlink" title="cpp删除容器中重复元素的方法："></a>cpp删除容器中重复元素的方法：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a.<span class="built_in">erase</span>(<span class="built_in">unique</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()),a.<span class="built_in">end</span>())；</span><br></pre></td></tr></table></figure>

<h4 id="stl中有关排列组合的api"><a href="#stl中有关排列组合的api" class="headerlink" title="stl中有关排列组合的api"></a>stl中有关排列组合的api</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//func();</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()))</span><br></pre></td></tr></table></figure>

<h4 id="头文件中的模板类编译时的一个坑及其原因"><a href="#头文件中的模板类编译时的一个坑及其原因" class="headerlink" title="头文件中的模板类编译时的一个坑及其原因"></a>头文件中的模板类编译时的一个坑及其原因</h4><p>如果把模板类的声明和定义都放在头文件中。需要用到模板类的时候，只需要包含该头文件，然后进行实例化。</p>
<p>如果模板类的声明和定义分别放在头文件和源文件中。当实例化的时候，只包含头文件会发证链接错误。</p>
<p>原因是模板类的实例化要分成两个步骤，模板的特例化和特例的实例化。</p>
<p>编译器在编译阶段，由于没有定义，所以编译器不能生成具体的模板特例，但是这并不会报错误，编译器将把问题抛给链接器来做。在编译源文件的时候，程序找不到该模板的特例，只是有模板而已，所以无法生成对象。所以会发生错误。</p>
<h4 id="lower-bound-amp-amp-upper-bound"><a href="#lower-bound-amp-amp-upper-bound" class="headerlink" title="lower_bound &amp;&amp; upper_bound"></a>lower_bound &amp;&amp; upper_bound</h4><p>lower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找元素的方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在从小到大的排序数组中,以vector&lt;int&gt; nums为例子</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="type">int</span> idx = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target) - nums.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> idx = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target) - nums.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在从大到小的排序数组中，重载lower_bound()和upper_bound()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure>

<h4 id="能读入空格和回车符的输入方式"><a href="#能读入空格和回车符的输入方式" class="headerlink" title="能读入空格和回车符的输入方式"></a>能读入空格和回车符的输入方式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> (cin.<span class="built_in">peek</span>() != EOF) &#123;</span><br><span class="line">    c = cin.<span class="built_in">get</span>();</span><br><span class="line">    s += c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
  </entry>
</search>
